/*
 * generated by Xtext 2.12.0
 */
package org.xtext.robotFinal.validation


import org.xtext.robotFinal.marsRover.Robot
import org.xtext.robotFinal.marsRover.detect_lakes
import org.xtext.robotFinal.marsRover.ultra
import org.xtext.robotFinal.marsRover.detect_rocks
import org.xtext.robotFinal.marsRover.color_indication
import org.xtext.robotFinal.marsRover.Color

import org.eclipse.xtext.validation.Check

import org.xtext.robotFinal.generator.MarsRoverGenerator 


/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class MarsRoverValidator extends AbstractMarsRoverValidator {
	
@Check
	def checkNumberOfLakes(detect_lakes dl) {
		if (dl.lakes_colors.length != dl.number_of_lakes){
			error("Number of lakes must match number of corresponding colors", null)
		}
	}
	
	@Check
	def macValidation(Robot r) {
		if (r.slave_address.length != 12){
			error("MAC must be 12 hexa decimal characters long", null);
		}
	}
	
	@Check
	def checkSpeeds(Robot r){
		if (r.drive_speed == r.special_speed){
			warning("Special and drive speeds are the same, you might want them different", null)
		}
	}
	
	@Check
	def checkUltrasonicDistance(ultra u){
		if (u.distance < 5 && u.distance > 255){
			error("Distance out of bounds [5, 255]", null);
		}
	}
	
	/*@Check
	def checkStopContinue(Robot r){
		var error_cnt = 0;
		var error_cnt_reverse = 0;
		for (var i = 0; i < r.missions.length; i++){
			if ( MarsRoverGenerator.typeToText(r.missions.get(i).type ) == "detect_rocks"){
				if ( (r.missions.get(i).type as detect_rocks).after_examinating.action == 'stop' ){
					error_cnt = error_cnt + 1;
				}
			}
			if ( MarsRoverGenerator.typeToText(r.missions.get(i).type ) == "detect_lakes"){
				if ( (r.missions.get(i).type as detect_lakes).after_examinating.action == 'continue' ){
					error_cnt = error_cnt + 1;
				}
			}
			if ( MarsRoverGenerator.typeToText(r.missions.get(i).type ) == "detect_rocks"){
				if ( (r.missions.get(i).type as detect_rocks).after_examinating.action == 'continue' ){
					error_cnt_reverse = error_cnt_reverse + 1;
				}
			}
			if ( MarsRoverGenerator.typeToText(r.missions.get(i).type ) == "detect_lakes"){
				if ( (r.missions.get(i).type as detect_lakes).after_examinating.action == 'stop' ){
					error_cnt_reverse = error_cnt_reverse + 1;
				}
			}
		}
		if (error_cnt == 2 || error_cnt_reverse == 2){
			error("Cannot stop and continue at the same time", null);	
		}
	}*/
	
	@Check
	def checkSameMissions(Robot r){
		for (var i = 0; i < r.missions.length; i++){
			for (var j = 0; j < r.missions.length; j++){
				if ( MarsRoverGenerator.typeToText(r.missions.get(i).type ) == MarsRoverGenerator.typeToText(r.missions.get(j).type ) && i != j){
					error("Duplicate of mission found", null);
				} 
				if  ( MarsRoverGenerator.typeToText(r.missions.get(i).type ) == "avoid_lakes" &&
					MarsRoverGenerator.typeToText(r.missions.get(j).type ) == "detect_lakes"){
					error("Cannot detect and avoid lakes at the same time", null)
				} 
				if  ( MarsRoverGenerator.typeToText(r.missions.get(i).type ) == "avoid_obstacles" &&
					MarsRoverGenerator.typeToText(r.missions.get(j).type ) == "push_obstacles"){
					error("Cannot push and avoid obstacles at the same time", null)
				} 
				if  ( MarsRoverGenerator.typeToText(r.missions.get(i).type ) == "detect_rocks" &&
					MarsRoverGenerator.typeToText(r.missions.get(j).type ) == "push_obstacles"){
					error("Cannot push and detect rocks at the same time", null)
				}
				if  ( MarsRoverGenerator.typeToText(r.missions.get(i).type ) == "detect_rocks" &&
					MarsRoverGenerator.typeToText(r.missions.get(j).type ) == "avoid_obstacles"){
					error("Cannot avoid and detect rocks at the same time", null)
				}
			}
		}
	}
}