/*
 * generated by Xtext 2.12.0
 */
package org.xtext.robotFinal.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.xtext.robotFinal.marsRover.MarsRoverPackage;
import org.xtext.robotFinal.marsRover.Robot;
import org.xtext.robotFinal.marsRover.after_action;
import org.xtext.robotFinal.marsRover.avoid_lakes;
import org.xtext.robotFinal.marsRover.avoid_obstacles;
import org.xtext.robotFinal.marsRover.bumpers;
import org.xtext.robotFinal.marsRover.color_indication;
import org.xtext.robotFinal.marsRover.detect_lakes;
import org.xtext.robotFinal.marsRover.detect_rocks;
import org.xtext.robotFinal.marsRover.indication;
import org.xtext.robotFinal.marsRover.message;
import org.xtext.robotFinal.marsRover.mission;
import org.xtext.robotFinal.marsRover.park;
import org.xtext.robotFinal.marsRover.push_obstacles;
import org.xtext.robotFinal.marsRover.sound;
import org.xtext.robotFinal.marsRover.ultra;
import org.xtext.robotFinal.services.MarsRoverGrammarAccess;

@SuppressWarnings("all")
public class MarsRoverSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private MarsRoverGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == MarsRoverPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case MarsRoverPackage.ROBOT:
				sequence_Robot(context, (Robot) semanticObject); 
				return; 
			case MarsRoverPackage.AFTER_ACTION:
				sequence_after_action(context, (after_action) semanticObject); 
				return; 
			case MarsRoverPackage.AVOID_LAKES:
				sequence_avoid_lakes(context, (avoid_lakes) semanticObject); 
				return; 
			case MarsRoverPackage.AVOID_OBSTACLES:
				sequence_avoid_obstacles(context, (avoid_obstacles) semanticObject); 
				return; 
			case MarsRoverPackage.BUMPERS:
				sequence_bumpers(context, (bumpers) semanticObject); 
				return; 
			case MarsRoverPackage.COLOR_INDICATION:
				sequence_color_indication(context, (color_indication) semanticObject); 
				return; 
			case MarsRoverPackage.DETECT_LAKES:
				sequence_detect_lakes(context, (detect_lakes) semanticObject); 
				return; 
			case MarsRoverPackage.DETECT_ROCKS:
				sequence_detect_rocks(context, (detect_rocks) semanticObject); 
				return; 
			case MarsRoverPackage.INDICATION:
				sequence_indication(context, (indication) semanticObject); 
				return; 
			case MarsRoverPackage.MESSAGE:
				sequence_message(context, (message) semanticObject); 
				return; 
			case MarsRoverPackage.MISSION:
				sequence_mission(context, (mission) semanticObject); 
				return; 
			case MarsRoverPackage.PARK:
				sequence_park(context, (park) semanticObject); 
				return; 
			case MarsRoverPackage.PUSH_OBSTACLES:
				sequence_push_obstacles(context, (push_obstacles) semanticObject); 
				return; 
			case MarsRoverPackage.SOUND:
				sequence_sound(context, (sound) semanticObject); 
				return; 
			case MarsRoverPackage.ULTRA:
				sequence_ultra(context, (ultra) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Robot returns Robot
	 *
	 * Constraint:
	 *     (name=STRING slave_address=STRING drive_speed=INT special_speed=INT missions+=mission*)
	 */
	protected void sequence_Robot(ISerializationContext context, Robot semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     after_action returns after_action
	 *
	 * Constraint:
	 *     ((action='stop' | action='continue') indicate+=indication*)
	 */
	protected void sequence_after_action(ISerializationContext context, after_action semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     avoid_lakes returns avoid_lakes
	 *
	 * Constraint:
	 *     name='avoid_lakes'
	 */
	protected void sequence_avoid_lakes(ISerializationContext context, avoid_lakes semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MarsRoverPackage.Literals.AVOID_LAKES__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MarsRoverPackage.Literals.AVOID_LAKES__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAvoid_lakesAccess().getNameAvoid_lakesKeyword_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     avoid_obstacles returns avoid_obstacles
	 *
	 * Constraint:
	 *     (name='avoid_obstacles' (sensors+=ultra | sensors+=bumpers)*)
	 */
	protected void sequence_avoid_obstacles(ISerializationContext context, avoid_obstacles semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     bumpers returns bumpers
	 *
	 * Constraint:
	 *     name='bumpers'
	 */
	protected void sequence_bumpers(ISerializationContext context, bumpers semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MarsRoverPackage.Literals.BUMPERS__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MarsRoverPackage.Literals.BUMPERS__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBumpersAccess().getNameBumpersKeyword_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     color_indication returns color_indication
	 *
	 * Constraint:
	 *     (name='color_indication' color=LED_Color)
	 */
	protected void sequence_color_indication(ISerializationContext context, color_indication semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MarsRoverPackage.Literals.COLOR_INDICATION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MarsRoverPackage.Literals.COLOR_INDICATION__NAME));
			if (transientValues.isValueTransient(semanticObject, MarsRoverPackage.Literals.COLOR_INDICATION__COLOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MarsRoverPackage.Literals.COLOR_INDICATION__COLOR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getColor_indicationAccess().getNameColor_indicationKeyword_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getColor_indicationAccess().getColorLED_ColorEnumRuleCall_2_0(), semanticObject.getColor());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     detect_lakes returns detect_lakes
	 *
	 * Constraint:
	 *     (name='detect_lakes' number_of_lakes=INT lakes_colors+=Color* after_examinating=after_action)
	 */
	protected void sequence_detect_lakes(ISerializationContext context, detect_lakes semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     detect_rocks returns detect_rocks
	 *
	 * Constraint:
	 *     (name='detect_rocks' number_of_rocks=INT after_examinating=after_action)
	 */
	protected void sequence_detect_rocks(ISerializationContext context, detect_rocks semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MarsRoverPackage.Literals.DETECT_ROCKS__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MarsRoverPackage.Literals.DETECT_ROCKS__NAME));
			if (transientValues.isValueTransient(semanticObject, MarsRoverPackage.Literals.DETECT_ROCKS__NUMBER_OF_ROCKS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MarsRoverPackage.Literals.DETECT_ROCKS__NUMBER_OF_ROCKS));
			if (transientValues.isValueTransient(semanticObject, MarsRoverPackage.Literals.DETECT_ROCKS__AFTER_EXAMINATING) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MarsRoverPackage.Literals.DETECT_ROCKS__AFTER_EXAMINATING));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDetect_rocksAccess().getNameDetect_rocksKeyword_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getDetect_rocksAccess().getNumber_of_rocksINTTerminalRuleCall_2_0(), semanticObject.getNumber_of_rocks());
		feeder.accept(grammarAccess.getDetect_rocksAccess().getAfter_examinatingAfter_actionParserRuleCall_4_0(), semanticObject.getAfter_examinating());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     indication returns indication
	 *
	 * Constraint:
	 *     (name='with' (type=sound | type=message | type=color_indication)?)
	 */
	protected void sequence_indication(ISerializationContext context, indication semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     message returns message
	 *
	 * Constraint:
	 *     (name='message' msg=STRING)
	 */
	protected void sequence_message(ISerializationContext context, message semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MarsRoverPackage.Literals.MESSAGE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MarsRoverPackage.Literals.MESSAGE__NAME));
			if (transientValues.isValueTransient(semanticObject, MarsRoverPackage.Literals.MESSAGE__MSG) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MarsRoverPackage.Literals.MESSAGE__MSG));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMessageAccess().getNameMessageKeyword_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getMessageAccess().getMsgSTRINGTerminalRuleCall_1_0(), semanticObject.getMsg());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     mission returns mission
	 *
	 * Constraint:
	 *     (name=STRING (type=avoid_obstacles | type=detect_lakes | type=avoid_lakes | type=push_obstacles | type=detect_rocks))
	 */
	protected void sequence_mission(ISerializationContext context, mission semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     park returns park
	 *
	 * Constraint:
	 *     name='park'
	 */
	protected void sequence_park(ISerializationContext context, park semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MarsRoverPackage.Literals.PARK__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MarsRoverPackage.Literals.PARK__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getParkAccess().getNameParkKeyword_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     push_obstacles returns push_obstacles
	 *
	 * Constraint:
	 *     name='push_obstacles'
	 */
	protected void sequence_push_obstacles(ISerializationContext context, push_obstacles semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MarsRoverPackage.Literals.PUSH_OBSTACLES__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MarsRoverPackage.Literals.PUSH_OBSTACLES__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPush_obstaclesAccess().getNamePush_obstaclesKeyword_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     sound returns sound
	 *
	 * Constraint:
	 *     (name='sound' duration=INT frequency=INT)
	 */
	protected void sequence_sound(ISerializationContext context, sound semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MarsRoverPackage.Literals.SOUND__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MarsRoverPackage.Literals.SOUND__NAME));
			if (transientValues.isValueTransient(semanticObject, MarsRoverPackage.Literals.SOUND__DURATION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MarsRoverPackage.Literals.SOUND__DURATION));
			if (transientValues.isValueTransient(semanticObject, MarsRoverPackage.Literals.SOUND__FREQUENCY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MarsRoverPackage.Literals.SOUND__FREQUENCY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSoundAccess().getNameSoundKeyword_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getSoundAccess().getDurationINTTerminalRuleCall_2_0(), semanticObject.getDuration());
		feeder.accept(grammarAccess.getSoundAccess().getFrequencyINTTerminalRuleCall_4_0(), semanticObject.getFrequency());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ultra returns ultra
	 *
	 * Constraint:
	 *     (name='ultra' distance=INT)
	 */
	protected void sequence_ultra(ISerializationContext context, ultra semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MarsRoverPackage.Literals.ULTRA__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MarsRoverPackage.Literals.ULTRA__NAME));
			if (transientValues.isValueTransient(semanticObject, MarsRoverPackage.Literals.ULTRA__DISTANCE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MarsRoverPackage.Literals.ULTRA__DISTANCE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getUltraAccess().getNameUltraKeyword_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getUltraAccess().getDistanceINTTerminalRuleCall_2_0(), semanticObject.getDistance());
		feeder.finish();
	}
	
	
}
